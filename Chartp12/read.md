## Chartp12 动态内存与智能指针

#### shared_ptr类
智能指针也是模板，使用方式与普通指针类似。解引用一个智能指针返回它指向的对象。
支持操作如下：
```c++
std::shared_ptr<T> sp;

*p; // 解引用p，获得它指向的对象
p.get(); //	返回p中的指针。
swap(p, q); // 交换p、q的指针
p.swap(q); 


// 特有的操作
p = q; // p、q都是shared_ptr，此操作会递减p的引用计数、递增q的引用计数；若p的引用计数变成0，则将其管理的内存释放

p.user_count(); // 返回共享对象的智能指针数量
```

#### 使用动态生存期的资源类
程序使用动态内存出于一下三个原因：
1）程序不知道自己需要使用多少对象
2）程序不知道所需对象的准确类型
3）程序需要在多个对象间共享数据

StrBlob类

#### 直接管理内存
在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回指向该对象的指针。
```c++
int* pi = new int; // pi指向一个动态分配的、未初始化的无名对象
```
默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或者组合类型的对象的值将是未定义的，而类类型的对象将用默认构造函数进行初始化。

可以使用直接初始化的方式来初始化一个动态分配的对象，可以使用传统的构造方式(使用圆括号)，也可以使用列表初始化{使用花括号}。
```c++
std::string* ps1 = new std::string;
std::string* ps = new std::string();
int* pi1 = new int;   // 默认初始化
int* pi2 = new int(); // 值初始化，pi2为0
```
#### 动态分配的const对象
用new分配const对象是合法的
```c++
const int* pi = new const int(1024);
```
#### 内存耗尽
一旦一个程序用光了所有它可用的内存，new表达式就会失败。默认情况下，如果new不能分配所要求的空间，它会抛出一个bad_alloc的异常。 我们可以改变new的使用方式来阻止它抛出异常。
```c++
int* p1 = new int; // 如果分配失败，抛出bad_alloc异常
int* p2 = new (nothrow) int; // 如果分配失败，返回空指针。
```

#### shared_ptr和new结合使用
如果我们不初始化一个智能指针，它就会被初始化为一个空指针。
```c++
shared_ptr<double> p1;
shared_ptr<int> p2(new int(42));
```

不能将一个内置指针隐式转换成一个智能指针。
```c++
shared<int> clone(int p) {
	return new int(p); // ERROR，不能隐式转换
}


p.reset(q, d); //使用reset来将一个新的指针赋予一个shared_ptr。
p = new int(1024); // ERROR
p.reset(new int(1024)); // OK
```

#### 智能指针与异常
```c++
void f() {
	shared_ptr<int> sp(new int(42));
	// 此段代码抛出一个异常，且在f中未被捕获
    // 使用智能指针可以正确的释放内存
}

函数退出有两种可能，正常处理结束或者发生了异常。无论哪种情况，拒不对象都会被销毁。
```
