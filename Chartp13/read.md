## 拷贝控制

一个类通过定义五中特殊成员函数来控制这些操作，包括：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数。

拷贝初始化：
```c++
string dots(10, '.'); // 直接初始化
string s(dots); 	  // 拷贝初始化
string s2 = dots; 	  // 拷贝初始化
string null_book = "9-99-999-9"; // 拷贝初始化
string ninjes = std::string(100, '9'); // 拷贝初始化
```
当我们使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要则进行类型转换。
拷贝初始化通常使用拷贝构造函数来完成，但是，如果一个类有移动构函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。

拷贝构造不仅在定义变量时发生，在下列情况也会发生：
1. 将一个对象作为实参传递一个非引用类型的形参
2. 从一个返回类型为非引用类型的函数返回一个对象。
3. 用花括号列表初始化一个数组中的元素或者一个聚合类中的成员。

#### 编译器可以绕过拷贝构造函数
在拷贝初始化过程中，编译器可以跳过拷贝/移动构造函数，直接创建对象。即，编译器允许将下面代码
```c++
std::string null_book = "9-99-999-9";
// 改写为
std::string null_book("9-99-999-9");
```
即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动必须是存在而且可以访问的。

#### 重载赋值运算符

重载运算符的参数表示运算符的运算对象，通常应该返回一个指向其左侧运算符对象的引用。

#### 三五法则
如前所述，有三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符、析构函数。
C++11标准下，还可以定义一个移动构造函数和一个移动赋值运算符。

###需要析构函数的类也需要拷贝和赋值操作。
当我们决定一个类是否要定义他自己版本的拷贝控制成员时，一个基本原则时首先确定这个类是否需要一个析构函数。如果一个类需要一个析构函数，我们几乎肯定推它也需要一个拷贝构造函数和一个拷贝赋值运算符。

###需要拷贝操作的类也需要赋值操作，反之亦然。
虽然很多类需要定义所有拷贝控制成员，但是某些类所要完成的工作，只有拷贝或赋值操作。

### 阻止拷贝
iostream类阻止了拷贝控制成员，以避免多个对象写入或读取相同的IO缓冲。

1. 定义删除函数
```c++
struct NoCopy {
	NoCopy() = default();
	NoCopy(const NoCopy&)  = delete; // 阻止拷贝
	NoCopy& operator=(const NoCopy&) = delete; // 阻止赋值
};
```
与default不同的是，我们可以对任何函数指定=delete，在我们希望引导函数匹配过程时，删除函数也是有用的。

析构函数不能是删除的成员。
```c++
struct NoDtor {
	NoDtor() = default;
	~NoDtor() = delete;
};
```

2. private拷贝控制
在新标准之前，类通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝。
```c++
class PrivateCopy {
public:
	PrivateCopy() = default;
private:
	PrivateCopy(const PrivateCopy&);
	PrivateCopy&* operator=(const PrivateCopy&);
};
```

声明但是不定义一个成员函数时合法的，试图访问一个未定义的成员函数将导致一个链接错误。
通过声明pricate的拷贝构造函数，我们可以预先阻止任何拷贝该类型对象的企图。
