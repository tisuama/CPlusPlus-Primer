## 拷贝控制

一个类通过定义五中特殊成员函数来控制这些操作，包括：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数。

拷贝初始化：
```c++
string dots(10, '.'); // 直接初始化
string s(dots); 	  // 拷贝初始化
string s2 = dots; 	  // 拷贝初始化
string null_book = "9-99-999-9"; // 拷贝初始化
string ninjes = std::string(100, '9'); // 拷贝初始化
```
当我们使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要则进行类型转换。
拷贝初始化通常使用拷贝构造函数来完成，但是，如果一个类有移动构函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。

拷贝构造不仅在定义变量时发生，在下列情况也会发生：
1. 将一个对象作为实参传递一个非引用类型的形参
2. 从一个返回类型为非引用类型的函数返回一个对象。
3. 用花括号列表初始化一个数组中的元素或者一个聚合类中的成员。

#### 编译器可以绕过拷贝构造函数
在拷贝初始化过程中，编译器可以跳过拷贝/移动构造函数，直接创建对象。即，编译器允许将下面代码
```c++
std::string null_book = "9-99-999-9";
// 改写为
std::string null_book("9-99-999-9");
```
即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动必须是存在而且可以访问的。

#### 重载赋值运算符

重载运算符的参数表示运算符的运算对象，通常应该返回一个指向其左侧运算符对象的引用。

#### 三五法则
如前所述，有三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符、析构函数。
C++11标准下，还可以定义一个移动构造函数和一个移动赋值运算符。

#### 需要析构函数的类也需要拷贝和赋值操作。
当我们决定一个类是否要定义他自己版本的拷贝控制成员时，一个基本原则时首先确定这个类是否需要一个析构函数。如果一个类需要一个析构函数，我们几乎肯定推它也需要一个拷贝构造函数和一个拷贝赋值运算符。

#### 需要拷贝操作的类也需要赋值操作，反之亦然。
虽然很多类需要定义所有拷贝控制成员，但是某些类所要完成的工作，只有拷贝或赋值操作。

### 阻止拷贝
iostream类阻止了拷贝控制成员，以避免多个对象写入或读取相同的IO缓冲。

1. 定义删除函数
```c++
struct NoCopy {
	NoCopy() = default();
	NoCopy(const NoCopy&)  = delete; // 阻止拷贝
	NoCopy& operator=(const NoCopy&) = delete; // 阻止赋值
};
```
与default不同的是，我们可以对任何函数指定=delete，在我们希望引导函数匹配过程时，删除函数也是有用的。

析构函数不能是删除的成员。
```c++
struct NoDtor {
	NoDtor() = default;
	~NoDtor() = delete;
};
```

2. private拷贝控制
在新标准之前，类通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝。
```c++
class PrivateCopy {
public:
	PrivateCopy() = default;
private:
	PrivateCopy(const PrivateCopy&);
	PrivateCopy&* operator=(const PrivateCopy&);
};
```

声明但是不定义一个成员函数时合法的，试图访问一个未定义的成员函数将导致一个链接错误。
通过声明pricate的拷贝构造函数，我们可以预先阻止任何拷贝该类型对象的企图。

#### 拷贝控制和资源管理
- 类行为像一个值，意味着他应该有自己的状态。当我们拷贝一个像值得对象时，副本和原对象时完全独立的。
- 类行为像一个指针，则类是共享状态。当我们拷贝这种类对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。
可以使用shared_ptr来管理类中的资源，也可以使用引用计数的方法。

### 引用计数
引用计数的工作方式如下：
1. 除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数。
2. 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器。
3. 析构函数递减计数器。
4. 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧的运算对象的计数器。

### 交换操作（新的操作，和移动区分开）
除了定义拷贝控制成员，管理资源类通常还定义一个名为swap的函数。
如果一个类定义了自己的swap函数，那么算法将使用类自定义版本，否则算法将使用标准库定义个swap。

但是如果一个类的成员有自己特定类型的swap函数，调用std::swap就是错误的了（指没有执行正确的swap）。

如果Foo类含有HasPtr类，swap函数如下：
```c++
void swap(Foo& lhs, Foo& rhs) {
	// 使用了标准库里的swap，而不是HasPtr的版本
	std::swap(lhs.h, rhs.h);
}
```

每个swap调用都应该是未加限定的。即，每个调用都应是swap，而不是std::swap。如果存在特定版本的swap，其匹配程度会优于std中定义等版本。
```c++
void swap(Foo& lhs, Foo& rhs) {
	using std::swap;
	swap(lhs.h, rhs.h);
}
```
#### 在赋值运算符中使用swap

定义swap函数的类通常使用swap来定义它们的赋值运算符。这些运算符使用了一种名为拷贝并交换的技术（copy and swap)。
```c++
HasPtr& HasPtr::operator=(HasPtr rhs) {
	swap(*this, rhs);
	return *this;
}
```

### 对象移动
在重新分配内存的过程中，从旧内从将元素拷贝到新内存是不必要的，更好的方式是移动元素。使用移动而不是拷贝的另外一个原因是源于IO类或`unique_ptr`这样的类。这些类都包含已能被共享的资源（如指针或者IO缓冲）。因此这些类型的对象不能拷贝但是可以移动。

在旧的C++标准中，没有直接的方法移动对象。因此在不必拷贝对象的情况下，我们也不得不拷贝。
在旧的标准中，容器所保存的类必须是可以拷贝的。但是在新的标准中，我们可以用容器保存不可拷贝的类型，只要他们能被移动即可。

### 右值引用
为了支持移动操作，新标准引入了一种新的引用类型：右值引用。右值引用有一个重要的性质-只能绑定到一个将要销毁的对象。因此，我们可以自由的将一个右值引用的资源“移动”到另一个对象中。

类似任何引用，一个右值引用可不过是某个对象的另一个名字而已。如我们所知，左值引用不能绑定到要求转换的表达式、字面常量或者返回右值的表达式。右值引用则有着完全相反的绑定特性：我们可以将右值引用绑定到这类表达式上，但是不能将一个右值引用直接绑定到一个左值上。

```c++
int i = 42;
int& r = i;     // ERROR
int&& rr = i;   // OK
int& r2 = i * 42; // ERROR
const int& r3 = i * 42;  // OK
int&& rr2 = i * 42; //OK
```

##### 左值持久,右值短暂
左值右值的区别之处：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值的过程中创建的临时对象。
由于右值引用只能绑定到临时对象，我们得知：
-	所引用的对象将要被销毁
-	该对象没有其他用户
这两个特性意味着：使用右值引用的代码可以自由的接管所引用的对象的资源。

##### 变量是左值
变量可以看做只有一个运算对象而没有运算符的表达式。类似任何表达式，变量表达式也有左值/右值的属性。变量表达式都是左值，带来的结果就是：我们不能将一个右值引用绑定到一个右值引用类型的变量上：
```c++
int&& rr1 = 42;
int&& rr2 =	rr1; // ERROR
```

#### 标准库move函数
虽然不能将一个右值引用直接绑定到一个左值上，但是我们可以显式的将一个左值转换为对应的右值引用类型。 

我们可以通过调用一个`std::move`函数来获得绑定到左值上的右值引用，在头文件`unility`中。
```c++
int&& rr3 = std::move(rr1); // OK
```

我们可以销毁一个移后源对象，也可以赋予它新值，但是不能使用移后源对象的值。

#### 移动构造函数和移动赋值运算符
类似string类，我们自己的类也同时支持移动和拷贝，那么也能从中受益。类似拷贝构造函数，移动构造函数第一个参数是该类类型的一个引用，不同于拷贝构造函数，这个引用参数在移动构造函数中是一个右值引用。
```c++
StrVec::StrVec(StrVec&& s) noexcept 
	: elements(s.elements), first_free(s.first_free), cap(s.cap) {
	s.elements = s.first_free = s.cap = nullptr;
}
```

与拷贝构造函数不同，移动构造函数不分配任何新内存：它接管给定的StrVec中的内存。接管内存之后，它将给定对象中的指针都置为nullptr。

#### 移动操作、标准库容器与异常
由于移动操作“窃取”资源，它通常不分配任何资源。因此，移动操作通常不会抛出异常。

为了通知标准库移动操作不会抛出异常，需要通知标准库，使其不会为抛出异常这种可能而做一些额外的工作。一种通知标准库的方法是在我们构造函数中指明`noexcept`（C++11引入)。在构造函数中`noexcept`出现在列表开始的冒号之间。

```c++
class StrVec {
public:
	StrVec(StrVec&&) noexcept;
};
StrVec::StrVec(StrVec&& s) noexcept;
```
!必须在类声明和定义中都指定noexcept;

#### 移动赋值运算符
移动赋值运算符执行与析构函数和移动构造函数相同的工作。如果我们的移动赋值运算符不抛出异常，我们应该将它标记为noexcept。

```c++
StrVec& StrVec::operator=(StrVec&& rhs) noexcept {
	if (this != &rhs) { // 注意检查
		free();
		elements = rhs.elements;
		first_free = rhs.first_free;
		cap = rhs.cap;
		rhs.elements = rhs.first_free = rhs.cap = nullptr;
	}
	return *this;
}
```

#### 移后源对象必须可析构
从一个对象移动数据并不会销毁次对象，但有时在移动操作完成之后，源对象会被销毁。因此，当我们编写一个移动操作时，必须确保移后源对象进去一个可析构的状态。

#### 合成的移动操作
与处理拷贝构造函数和拷贝赋值运算符一样，编译器也会合成移动构造函数和移动赋值运算符。
与拷贝操作不同，编译器根本不会为某些类合成移动操作。特别是，如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符。

只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。

移动操作和合成的拷贝控制成员间还有最后一个相互作用关系：一个类是否定义了自己的移动操作对拷贝操作如何合成有影响。如果类定义了一个移动构造函数或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。

### 移动右值，拷贝左值

如果没有移动构造函数，右值也被拷贝
```c++
class Foo {
public:
	Foo() = default;
	Foo(const Foo&);
};
Foo x;
Foo y(x);
Foo z(std::move(x)); // 拷贝构造函数，因为未定义移动构造函数
```
