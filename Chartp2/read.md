## Chartp2 基础
#### 2.3 复合类型
1. 引用并非对象，相反的，它只是为一个已经存在的对象起另外一个名字。
```
int &ref = 10; // ERROR
```
2. 指针和引用不同的点：1）指针本省就是一个对象，允许指针赋值与套杯，而且在生命周期内他可以先后指向不同的对象 2）指针无需在定义时赋初值

3. 空指针（null pointer） 不指向任何对象，nullptr是一种特殊的字面值，他可以被转换成任意其他的指针类型。 `NULL`是一个预处理变量，在`csrtdlib`中，它的值为jumjmhfgvikkj,mnm,.l.0

>	`void*`指针是一种特殊的指针，可以存放任意对象的地址；不能直接操作`void*`指针所指对象，因为我们不知道这个对象到底是什么类型。

> 指向指针的指针，通过`*`的个数可以区分指针的级别，也就是`**`表示指针的指针。

> 指向指针的引用。引用本身不是一个对象，不能定义引用的指针，但是可以存在指针的引用。PS：要理解r类型到底是什么，简单的办法是从右向左阅读r的定义，离变量名最近的符号对变量的类型有罪直接的影响。
```
int i = 42;
int *p;
int *&r = p;
```


#### 2.4 const 限定符
1. const 对象一旦创建后其值就不会改变，所以const对象必须初始化
2. 默认情况下const对象仅在文件内有效。当以编译时初始化的方式定义一个const对象时，编译器会在编译过程中把用到该变量的地方替换成对应的值。为了执行上诉替换，编译器必须知道变量的初始值，如果包含多个文件，则用了const对象的文件必须能够访问到他的初始值他行。当多个文件出现同名const变量时，等于在不同文件中分别定义了该变量，所以为了支持这一做法，同时为了避免对同一变量的重复定义，const对象设置为文件内有效。

3. const引用，称为对常量的引用，表示不能修改它所绑定的对象。

4. 常量引用 -> 常量指针(pointer to const) -> 指针常量(const pointer)

```
const double pi = 3.14;
double *ptr = &pi; // ERROR
const double *cptr = &pt; //OK
double dval = 3.14;
cptr = &dval; // OK
```

5. constexpr：指值不会改变，且在编译过程中就能计算得到结果的表达式。
```
const int max_files = 20; // 常量表达式
const int limit = max_files + 1; // 常量表达式
const int sz = get_size(); // 非常量表达式
```
在一个复杂系统中，很难分辨是不是常量表达式，C++11允许将变量声明为constexpr来让编译器验证是否为常量表达式。声明为constexpr的变量一定是一个常量，且只能用常量表达式初始化。

constexpr修饰指针时限定符仅仅对指针有效，而对指针指向的类型无效。
```
const int* p = nullptr;
constexpr int* p = nullptr;
```
