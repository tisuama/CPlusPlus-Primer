## Chartp3 字符串、向量和数组

#### 3.1 using 声明
使用using声明就可以直接访问命名空间中的名字。
```c++
using namespace::name;
```

位于头文件中的代码不应该使用using, 因为头文件的内容会拷贝到所有引用它的文件中去。如果头文件有某个using声明，那么每个使用了该头文件的文件就会有这个声明。

#### 3.2 标准库string
如果使用=初始化一个变量，实际上执行拷贝初始化，编译器吧等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行直接初始化。
```c++
string s5 = "hiya";
```

#### 3.3 vectror对象

C++11提供了另外一种为vector对象元素赋初值的方法，即列表初始化。
```c++
vector<string> articles = {"a", "an", "the"};
```

#### 3.5 数组
数组是一种复合类型，声明如下形式：a[d]。

字符数组有一种额外的初始化方式，可以使用字面值对此类数组进行初始化。

```c++
char a1[] = {'C', '+', '+'};
char a2[] = {'C', '+', '+', '0'};
char a3[] = "C++"; // 自动添加结束字符

```

数组不允许拷贝和赋值。
```c++
int a[] = {0, 1, 2};
int a2[] = a; // ERROR
int* a2 = a;  // OK
```

理解复杂数组声明：
```c++
int *ptrs[10];   // OK, ptrs是含有10个整形指针的数组
int& refs[10]; 	 // ERROR, 不存在引用的数组	
int *(&array)[10] = ptrs; // OK, arry是数组的引用，该数组含有10个指针
int (*parray)[10] = &array; // OK
int (&arrref)[10] = arr; 	// OK
```

数组还有一个特性：很多用到数组名字的地方，编译器都会自动将其替换为一个指向数组首元素的指针。
```c++
string names[] = {"one", "two", "three"};
string* p = &names[0];
string* p2 = names; // 等价于&names[0];
```

下标和指针
对数组执行下标运算其实就是对指向数据元素的指针执行下标运算。
```c++
int ia[] = {0, 2, 3, 6, 8};
int i = ia[2];  
int *p = ia; 	// 指向ia首元素
i = *(p + 2);	// 等价于i = ia[2];
int *p = &ia[2];
int j = p[1];
int k = p[-2];	// 负值索引
```

