## Chartp18

### 命名空间
与其他名字一样，命名空间的名字必须定义在定义它的作用域内保持唯一。命名空间既可以定义在全局作用域中，也可以在其他命名空间中，
但是不能定义在类或者函数内部。

#### 模板特例化
模板特例化必须定义在原始模板所属命名空间中。和其他命名空间类似，只要我们在命名空间中声明了特例化，就能在命名空间外定义它。

```c++
// 必须将模板特例化声明成std的成员
namespace std {
	template<>
	struct hash<Sales_data>;
}

// 在std空间中声明了模板特例化的声明后，就可以在命名空间std的外部定义它。
template<>
struct std::hash<Sales_data>
{
	// something
};
```

#### 内联命名空间
C++11引入新的嵌套命名空间，称为内联命名空间(inline namespace)。和普通嵌套命名空间不同，内联命名空间中的名字可以被外层命名空间直接使用。
也就是我们无需再内联命名空间的名字前面添加该命名空间名的前缀，通过外层命名空间名就可以访问。

#### 未命名的命名空间
未命名的命名空间(unnamed namespace)是指关键字namespace后紧跟花括号起来的一系列声明语句。未命名的命名空间定义的变量：它们在
第一次使用前创建，直到程序结束才销毁。

未命名的命名空间中定义的名字的作用域与该命名空间所在的作用域相同。
```c++
int i; // i的全局声明
namespace {
	int i; 	// ERROR
};
```

#### using 声明：扼要概述
`using`声明引入的名字遵守与过去一样的作用域规则：它的有效范围从using声明的地方开始，一直到using声明所在的作用域结束为止。

一条using声明语句可以出现在全局作用域、局部作用域、命名空间作用域以及类的作用域中。在类的作用域中，这样的声明语句只能指向基类成员。

#### using指示
using指示和using声明类似的地方是，我们可以使用命名空间名字的简写形式：和using声明不同的地方是，我们无法控制哪些名字是可见的，因为所有名字都是可见的。


using指示从using开始，后面是关键字namespace以及命名空间的名字。
