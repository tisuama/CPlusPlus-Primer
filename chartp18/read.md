## Chartp18 用于大型程序的工具

### 命名空间
与其他名字一样，命名空间的名字必须定义在定义它的作用域内保持唯一。命名空间既可以定义在全局作用域中，也可以在其他命名空间中，
但是不能定义在类或者函数内部。

#### 模板特例化
模板特例化必须定义在原始模板所属命名空间中。和其他命名空间类似，只要我们在命名空间中声明了特例化，就能在命名空间外定义它。

```c++
// 必须将模板特例化声明成std的成员
namespace std {
	template<>
	struct hash<Sales_data>;
}

// 在std空间中声明了模板特例化的声明后，就可以在命名空间std的外部定义它。
template<>
struct std::hash<Sales_data>
{
	// something
};
```

#### 内联命名空间
C++11引入新的嵌套命名空间，称为内联命名空间(inline namespace)。和普通嵌套命名空间不同，内联命名空间中的名字可以被外层命名空间直接使用。
也就是我们无需再内联命名空间的名字前面添加该命名空间名的前缀，通过外层命名空间名就可以访问。

#### 未命名的命名空间
未命名的命名空间(unnamed namespace)是指关键字namespace后紧跟花括号起来的一系列声明语句。未命名的命名空间定义的变量：它们在
第一次使用前创建，直到程序结束才销毁。

未命名的命名空间中定义的名字的作用域与该命名空间所在的作用域相同。
```c++
int i; // i的全局声明
namespace {
	int i; 	// ERROR
};
```

#### using 声明：扼要概述
using声明声明的是一个名字，而非特定的函数。
```c++
using NS::print; // 该函数所有版本都引入当前作用域中
```
一条using声明语句一次只引用命名空间的一个成员。

`using`声明引入的名字遵守与过去一样的作用域规则：它的有效范围从using声明的地方开始，一直到using声明所在的作用域结束为止。

一条using声明语句可以出现在全局作用域、局部作用域、命名空间作用域以及类的作用域中。在类的作用域中，这样的声明语句只能指向基类成员。
(通过在类内部使用using声明语句，可以将类的直接或间接基类中任何可访问成员标记出来。using声明中名字的访问权限由该using声明语句之前
的说明符来决定)

#### using指示
using指示和using声明类似的地方是，我们可以使用命名空间名字的简写形式：和using声明不同的地方是，我们无法控制哪些名字是可见的，因为所有名字都是可见的。


using指示从using开始，后面是关键字namespace以及命名空间的名字。

### 多重继承

派生类的派生列表中可以包含多个基类：
```c++
class Bear: public ZooAnimal {
class Panda: public Bear, public Endangered {
```

在C++11标准中，允许派生类从它的一个或几个基类中继承构造函数。但是，如果从多个基类中继承了相同的构造函数（即形参列表完全相同），则程序产生错误。

#### 多重继承的派生类的拷贝与移动操作。

多重继承的派生类如果定义了自己的拷贝/(赋值构造函数)和赋值运算符，则必须在完整的对象上执行拷贝、移动或赋值操作。只有当派生类是合成版本的
拷贝、移动或赋值成员时，才会对其基类部分执行这些操作。
```c++
Panda yingyang("ying yang");
Panda lingling = yingyang;
// 调用Bear的拷贝构造函数，后者先调用ZooAnimal的拷贝构造函数，一旦Bear部分完成，又调用Endangered的拷贝构造函数
```

合成移动赋值、拷贝赋值、拷贝构造函数都有类似的机理。

### 虚继承
虚继承的目的是令某个类做出声明，承诺共享它的基类。
```c++
class Raccoon: public virtual ZooAnimal {
class Bear: virtual public  ZooAnimal {
```
一个类可以有多个虚基类，构造次序：编译器直接按照基类声明顺序第其一次进行检查，以确认是否含有虚基类。如果有则先构造虚基类，
然后按照声明顺序逐一构造其他非虚基类。
